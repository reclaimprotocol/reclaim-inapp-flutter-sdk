const String
    MSWJS_BASE =
    '(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module \'"+i+"\'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n"use strict";\n\nvar _interceptors = require("@mswjs/interceptors");\nvar _browser = _interopRequireDefault(require("@mswjs/interceptors/lib/browser/presets/browser"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// const interceptors = require(\'@mswjs/interceptors\')\n// const browserInterceptors = require(\'@mswjs/interceptors/presets/browser\')\n\nconst interceptor = new _interceptors.BatchInterceptor({\n  name: \'my-interceptor\',\n  interceptors: _browser.default\n});\ninterceptor.apply();\nwindow.reclaimInterceptor = interceptor;\n\n// interceptor.on(\'request\', ({ request, requestId }) => {\n//     alert(request.method)\n// })\n\n// fetch("https://reqres.in/api/users/2")\n\n},{"@mswjs/interceptors":13,"@mswjs/interceptors/lib/browser/presets/browser":7}],2:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.decodeBuffer = decodeBuffer;\nexports.encodeBuffer = encodeBuffer;\nexports.isResponseWithoutBody = isResponseWithoutBody;\nexports.toArrayBuffer = toArrayBuffer;\n// src/utils/bufferUtils.ts\nvar encoder = new TextEncoder();\nfunction encodeBuffer(text) {\n  return encoder.encode(text);\n}\nfunction decodeBuffer(buffer, encoding) {\n  const decoder = new TextDecoder(encoding);\n  return decoder.decode(buffer);\n}\nfunction toArrayBuffer(array) {\n  return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);\n}\n\n// src/utils/responseUtils.ts\nvar RESPONSE_STATUS_CODES_WITHOUT_BODY = /* @__PURE__ */new Set([101, 103, 204, 205, 304]);\nfunction isResponseWithoutBody(status) {\n  return RESPONSE_STATUS_CODES_WITHOUT_BODY.has(status);\n}\n\n},{}],3:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.emitAsync = emitAsync;\nexports.toInteractiveRequest = toInteractiveRequest;\nexports.uuidv4 = uuidv4;\nvar _outvariant = require("outvariant");\nvar _deferredPromise = require("@open-draft/deferred-promise");\n// src/utils/uuid.ts\nfunction uuidv4() {\n  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == "x" ? r : r & 3 | 8;\n    return v.toString(16);\n  });\n}\n\n// src/utils/RequestController.ts\n\nvar RequestController = class {\n  constructor(request) {\n    this.request = request;\n    this.responsePromise = new _deferredPromise.DeferredPromise();\n  }\n  respondWith(response) {\n    (0, _outvariant.invariant)(this.responsePromise.state === "pending", \'Failed to respond to "%s %s" request: the "request" event has already been responded to.\', this.request.method, this.request.url);\n    this.responsePromise.resolve(response);\n  }\n};\n\n// src/utils/toInteractiveRequest.ts\nfunction toInteractiveRequest(request) {\n  const requestController = new RequestController(request);\n  Reflect.set(request, "respondWith", requestController.respondWith.bind(requestController));\n  return {\n    interactiveRequest: request,\n    requestController\n  };\n}\n\n// src/utils/emitAsync.ts\nasync function emitAsync(emitter, eventName, ...data) {\n  const listners = emitter.listeners(eventName);\n  if (listners.length === 0) {\n    return;\n  }\n  for (const listener of listners) {\n    await listener.apply(emitter, data);\n  }\n}\n\n},{"@open-draft/deferred-promise":14,"outvariant":18}],4:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.FetchInterceptor = void 0;\nvar _chunkKK6APRON = require("./chunk-KK6APRON.mjs");\nvar _chunkS72SKXXQ = require("./chunk-S72SKXXQ.mjs");\nvar _outvariant = require("outvariant");\nvar _deferredPromise = require("@open-draft/deferred-promise");\nvar _until = require("@open-draft/until");\n// src/interceptors/fetch/index.ts\n\n// src/utils/isPropertyAccessible.ts\nfunction isPropertyAccessible(obj, key) {\n  try {\n    obj[key];\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/interceptors/fetch/index.ts\nvar _FetchInterceptor = class extends _chunkS72SKXXQ.Interceptor {\n  constructor() {\n    super(_FetchInterceptor.symbol);\n  }\n  checkEnvironment() {\n    return typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined";\n  }\n  setup() {\n    const pureFetch = globalThis.fetch;\n    (0, _outvariant.invariant)(!pureFetch[_chunkS72SKXXQ.IS_PATCHED_MODULE], \'Failed to patch the "fetch" module: already patched.\');\n    globalThis.fetch = async (input, init) => {\n      var _a;\n      const requestId = (0, _chunkKK6APRON.uuidv4)();\n      const request = new Request(input, init);\n      this.logger.info("[%s] %s", request.method, request.url);\n      const {\n        interactiveRequest,\n        requestController\n      } = (0, _chunkKK6APRON.toInteractiveRequest)(request);\n      this.logger.info(\'emitting the "request" event for %d listener(s)...\', this.emitter.listenerCount("request"));\n      this.emitter.once("request", ({\n        requestId: pendingRequestId\n      }) => {\n        if (pendingRequestId !== requestId) {\n          return;\n        }\n        if (requestController.responsePromise.state === "pending") {\n          requestController.responsePromise.resolve(void 0);\n        }\n      });\n      this.logger.info("awaiting for the mocked response...");\n      const signal = interactiveRequest.signal;\n      const requestAborted = new _deferredPromise.DeferredPromise();\n      signal.addEventListener("abort", () => {\n        requestAborted.reject(signal.reason);\n      }, {\n        once: true\n      });\n      const resolverResult = await (0, _until.until)(async () => {\n        const listenersFinished = (0, _chunkKK6APRON.emitAsync)(this.emitter, "request", {\n          request: interactiveRequest,\n          requestId\n        });\n        await Promise.race([requestAborted,\n        // Put the listeners invocation Promise in the same race condition\n        // with the request abort Promise because otherwise awaiting the listeners\n        // would always yield some response (or undefined).\n        listenersFinished, requestController.responsePromise]);\n        this.logger.info("all request listeners have been resolved!");\n        const mockedResponse2 = await requestController.responsePromise;\n        this.logger.info("event.respondWith called with:", mockedResponse2);\n        return mockedResponse2;\n      });\n      if (requestAborted.state === "rejected") {\n        return Promise.reject(requestAborted.rejectionReason);\n      }\n      if (resolverResult.error) {\n        return Promise.reject(createNetworkError(resolverResult.error));\n      }\n      const mockedResponse = resolverResult.data;\n      if (mockedResponse && !((_a = request.signal) == null ? void 0 : _a.aborted)) {\n        this.logger.info("received mocked response:", mockedResponse);\n        if (isPropertyAccessible(mockedResponse, "type") && mockedResponse.type === "error") {\n          this.logger.info("received a network error response, rejecting the request promise...");\n          return Promise.reject(createNetworkError(mockedResponse));\n        }\n        const responseClone = mockedResponse.clone();\n        this.emitter.emit("response", {\n          response: responseClone,\n          isMockedResponse: true,\n          request: interactiveRequest,\n          requestId\n        });\n        const response = new Response(mockedResponse.body, mockedResponse);\n        Object.defineProperty(response, "url", {\n          writable: false,\n          enumerable: true,\n          configurable: false,\n          value: request.url\n        });\n        return response;\n      }\n      this.logger.info("no mocked response received!");\n      return pureFetch(request).then(response => {\n        const responseClone = response.clone();\n        this.logger.info("original fetch performed", responseClone);\n        this.emitter.emit("response", {\n          response: responseClone,\n          isMockedResponse: false,\n          request: interactiveRequest,\n          requestId\n        });\n        return response;\n      });\n    };\n    Object.defineProperty(globalThis.fetch, _chunkS72SKXXQ.IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, _chunkS72SKXXQ.IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.fetch = pureFetch;\n      this.logger.info(\'restored native "globalThis.fetch"!\', globalThis.fetch.name);\n    });\n  }\n};\nvar FetchInterceptor = exports.FetchInterceptor = _FetchInterceptor;\nFetchInterceptor.symbol = Symbol("fetch");\nfunction createNetworkError(cause) {\n  return Object.assign(new TypeError("Failed to fetch"), {\n    cause\n  });\n}\n\n},{"./chunk-KK6APRON.mjs":3,"./chunk-S72SKXXQ.mjs":5,"@open-draft/deferred-promise":14,"@open-draft/until":16,"outvariant":18}],5:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.InterceptorReadyState = exports.Interceptor = exports.IS_PATCHED_MODULE = void 0;\nexports.deleteGlobalSymbol = deleteGlobalSymbol;\nexports.getGlobalSymbol = getGlobalSymbol;\nvar _logger = require("@open-draft/logger");\nvar _strictEventEmitter = require("strict-event-emitter");\n// src/glossary.ts\nvar IS_PATCHED_MODULE = exports.IS_PATCHED_MODULE = Symbol("isPatchedModule");\n\n// src/Interceptor.ts\n\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar InterceptorReadyState = exports.InterceptorReadyState = /* @__PURE__ */(InterceptorReadyState2 => {\n  InterceptorReadyState2["INACTIVE"] = "INACTIVE";\n  InterceptorReadyState2["APPLYING"] = "APPLYING";\n  InterceptorReadyState2["APPLIED"] = "APPLIED";\n  InterceptorReadyState2["DISPOSING"] = "DISPOSING";\n  InterceptorReadyState2["DISPOSED"] = "DISPOSED";\n  return InterceptorReadyState2;\n})(InterceptorReadyState || {});\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = "INACTIVE" /* INACTIVE */;\n    this.emitter = new _strictEventEmitter.Emitter();\n    this.subscriptions = [];\n    this.logger = new _logger.Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info("constructing the interceptor...");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it\'s present.\n   */\n  apply() {\n    const logger = this.logger.extend("apply");\n    logger.info("applying the interceptor...");\n    if (this.readyState === "APPLIED" /* APPLIED */) {\n      logger.info("intercepted already applied!");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info("the interceptor cannot be applied in this environment!");\n      return;\n    }\n    this.readyState = "APPLYING" /* APPLYING */;\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info("found a running instance, reusing...");\n      this.on = (event, listener) => {\n        logger.info(\'proxying the "%s" listener\', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info(\'removed proxied "%s" listener!\', event);\n        });\n        return this;\n      };\n      this.readyState = "APPLIED" /* APPLIED */;\n      return;\n    }\n    logger.info("no running instance found, setting up a new instance...");\n    this.setup();\n    this.setInstance();\n    this.readyState = "APPLIED" /* APPLIED */;\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there\'s a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  setup() {}\n  /**\n   * Listen to the interceptor\'s public events.\n   */\n  on(event, listener) {\n    const logger = this.logger.extend("on");\n    if (this.readyState === "DISPOSING" /* DISPOSING */ || this.readyState === "DISPOSED" /* DISPOSED */) {\n      logger.info("cannot listen to events, already disposed!");\n      return this;\n    }\n    logger.info(\'adding "%s" event listener:\', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  dispose() {\n    const logger = this.logger.extend("dispose");\n    if (this.readyState === "DISPOSED" /* DISPOSED */) {\n      logger.info("cannot dispose, already disposed!");\n      return;\n    }\n    logger.info("disposing the interceptor...");\n    this.readyState = "DISPOSING" /* DISPOSING */;\n    if (!this.getInstance()) {\n      logger.info("no interceptors running, skipping dispose...");\n      return;\n    }\n    this.clearInstance();\n    logger.info("global symbol deleted:", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info("disposing of %d subscriptions...", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info("disposed of all subscriptions!", this.subscriptions.length);\n    }\n    this.emitter.removeAllListeners();\n    logger.info("destroyed the listener!");\n    this.readyState = "DISPOSED" /* DISPOSED */;\n  }\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info("retrieved global instance:", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info("set global instance!", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info("cleared global instance!", this.symbol.description);\n  }\n};\nexports.Interceptor = Interceptor;\n\n},{"@open-draft/logger":15,"strict-event-emitter":20}],6:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.XMLHttpRequestInterceptor = void 0;\nvar _chunk3YG2666Q = require("./chunk-3YG2666Q.mjs");\nvar _chunkKK6APRON = require("./chunk-KK6APRON.mjs");\nvar _chunkS72SKXXQ = require("./chunk-S72SKXXQ.mjs");\nvar _outvariant = require("outvariant");\nvar _until = require("@open-draft/until");\nvar _isNodeProcess = require("is-node-process");\n// src/interceptors/XMLHttpRequest/index.ts\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts\n\n// src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts\nfunction concatArrayBuffer(left, right) {\n  const result = new Uint8Array(left.byteLength + right.byteLength);\n  result.set(left, 0);\n  result.set(right, left.byteLength);\n  return result;\n}\n\n// src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts\nvar EventPolyfill = class {\n  constructor(type, options) {\n    this.AT_TARGET = 0;\n    this.BUBBLING_PHASE = 0;\n    this.CAPTURING_PHASE = 0;\n    this.NONE = 0;\n    this.type = "";\n    this.srcElement = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n    this.isTrusted = true;\n    this.composed = false;\n    this.cancelable = true;\n    this.defaultPrevented = false;\n    this.bubbles = true;\n    this.lengthComputable = true;\n    this.loaded = 0;\n    this.total = 0;\n    this.cancelBubble = false;\n    this.returnValue = true;\n    this.type = type;\n    this.target = (options == null ? void 0 : options.target) || null;\n    this.currentTarget = (options == null ? void 0 : options.currentTarget) || null;\n    this.timeStamp = Date.now();\n  }\n  composedPath() {\n    return [];\n  }\n  initEvent(type, bubbles, cancelable) {\n    this.type = type;\n    this.bubbles = !!bubbles;\n    this.cancelable = !!cancelable;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n  stopPropagation() {}\n  stopImmediatePropagation() {}\n};\n\n// src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts\nvar ProgressEventPolyfill = class extends EventPolyfill {\n  constructor(type, init) {\n    super(type);\n    this.lengthComputable = (init == null ? void 0 : init.lengthComputable) || false;\n    this.composed = (init == null ? void 0 : init.composed) || false;\n    this.loaded = (init == null ? void 0 : init.loaded) || 0;\n    this.total = (init == null ? void 0 : init.total) || 0;\n  }\n};\n\n// src/interceptors/XMLHttpRequest/utils/createEvent.ts\nvar SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== "undefined";\nfunction createEvent(target, type, init) {\n  const progressEvents = ["error", "progress", "loadstart", "loadend", "load", "timeout", "abort"];\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT ? ProgressEvent : ProgressEventPolyfill;\n  const event = progressEvents.includes(type) ? new ProgressEventClass(type, {\n    lengthComputable: true,\n    loaded: (init == null ? void 0 : init.loaded) || 0,\n    total: (init == null ? void 0 : init.total) || 0\n  }) : new EventPolyfill(type, {\n    target,\n    currentTarget: target\n  });\n  return event;\n}\n\n// src/utils/findPropertySource.ts\nfunction findPropertySource(target, propertyName) {\n  if (!(propertyName in target)) {\n    return null;\n  }\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName);\n  if (hasProperty) {\n    return target;\n  }\n  const prototype = Reflect.getPrototypeOf(target);\n  return prototype ? findPropertySource(prototype, propertyName) : null;\n}\n\n// src/utils/createProxy.ts\nfunction createProxy(target, options) {\n  const proxy = new Proxy(target, optionsToProxyHandler(options));\n  return proxy;\n}\nfunction optionsToProxyHandler(options) {\n  const {\n    constructorCall,\n    methodCall,\n    getProperty,\n    setProperty\n  } = options;\n  const handler = {};\n  if (typeof constructorCall !== "undefined") {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target, args, newTarget);\n      return constructorCall.call(newTarget, args, next);\n    };\n  }\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target;\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(propertySource, propertyName);\n      if (typeof (ownDescriptors == null ? void 0 : ownDescriptors.set) !== "undefined") {\n        ownDescriptors.set.apply(target, [nextValue]);\n        return true;\n      }\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue\n      });\n    };\n    if (typeof setProperty !== "undefined") {\n      return setProperty.call(target, [propertyName, nextValue], next);\n    }\n    return next();\n  };\n  handler.get = function (target, propertyName, receiver) {\n    const next = () => target[propertyName];\n    const value = typeof getProperty !== "undefined" ? getProperty.call(target, [propertyName, receiver], next) : next();\n    if (typeof value === "function") {\n      return (...args) => {\n        const next2 = value.bind(target, ...args);\n        if (typeof methodCall !== "undefined") {\n          return methodCall.call(target, [propertyName, args], next2);\n        }\n        return next2();\n      };\n    }\n    return value;\n  };\n  return handler;\n}\n\n// src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts\nfunction isDomParserSupportedType(type) {\n  const supportedTypes = ["application/xhtml+xml", "application/xml", "image/svg+xml", "text/html", "text/xml"];\n  return supportedTypes.some(supportedType => {\n    return type.startsWith(supportedType);\n  });\n}\n\n// src/utils/parseJson.ts\nfunction parseJson(data) {\n  try {\n    const json = JSON.parse(data);\n    return json;\n  } catch (_) {\n    return null;\n  }\n}\n\n// src/interceptors/XMLHttpRequest/utils/createResponse.ts\nfunction createResponse(request, body) {\n  const responseBodyOrNull = (0, _chunk3YG2666Q.isResponseWithoutBody)(request.status) ? null : body;\n  return new Response(responseBodyOrNull, {\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(request.getAllResponseHeaders())\n  });\n}\nfunction createHeadersFromXMLHttpReqestHeaders(headersString) {\n  const headers = new Headers();\n  const lines = headersString.split(/[\\r\\n]+/);\n  for (const line of lines) {\n    if (line.trim() === "") {\n      continue;\n    }\n    const [name, ...parts] = line.split(": ");\n    const value = parts.join(": ");\n    headers.append(name, value);\n  }\n  return headers;\n}\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts\nvar IS_MOCKED_RESPONSE = Symbol("isMockedResponse");\nvar IS_NODE = (0, _isNodeProcess.isNodeProcess)();\nvar XMLHttpRequestController = class {\n  constructor(initialRequest, logger) {\n    this.initialRequest = initialRequest;\n    this.logger = logger;\n    this.method = "GET";\n    this.url = null;\n    this.events = /* @__PURE__ */new Map();\n    this.requestId = (0, _chunkKK6APRON.uuidv4)();\n    this.requestHeaders = new Headers();\n    this.responseBuffer = new Uint8Array();\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case "ontimeout":\n            {\n              const eventName = propertyName.slice(2);\n              this.request.addEventListener(eventName, nextValue);\n              return invoke();\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        var _a;\n        switch (methodName) {\n          case "open":\n            {\n              const [method, url] = args;\n              if (typeof url === "undefined") {\n                this.method = "GET";\n                this.url = toAbsoluteUrl(method);\n              } else {\n                this.method = method;\n                this.url = toAbsoluteUrl(url);\n              }\n              this.logger = this.logger.extend(`\${this.method} \${this.url.href}`);\n              this.logger.info("open", this.method, this.url.href);\n              return invoke();\n            }\n          case "addEventListener":\n            {\n              const [eventName, listener] = args;\n              this.registerEvent(eventName, listener);\n              this.logger.info("addEventListener", eventName, listener);\n              return invoke();\n            }\n          case "setRequestHeader":\n            {\n              const [name, value] = args;\n              this.requestHeaders.set(name, value);\n              this.logger.info("setRequestHeader", name, value);\n              return invoke();\n            }\n          case "send":\n            {\n              const [body] = args;\n              if (body != null) {\n                this.requestBody = typeof body === "string" ? (0, _chunk3YG2666Q.encodeBuffer)(body) : body;\n              }\n              this.request.addEventListener("load", () => {\n                if (typeof this.onResponse !== "undefined") {\n                  const fetchResponse = createResponse(this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request\'s "responseType" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response);\n                  this.onResponse.call(this, {\n                    response: fetchResponse,\n                    isMockedResponse: IS_MOCKED_RESPONSE in this.request,\n                    request: fetchRequest,\n                    requestId: this.requestId\n                  });\n                }\n              });\n              const fetchRequest = this.toFetchApiRequest();\n              const onceRequestSettled = ((_a = this.onRequest) == null ? void 0 : _a.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId\n              })) || Promise.resolve();\n              onceRequestSettled.finally(() => {\n                if (this.request.readyState < this.request.LOADING) {\n                  this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...", this.request.readyState);\n                  if (IS_NODE) {\n                    this.request.setRequestHeader("X-Request-Id", this.requestId);\n                  }\n                  return invoke();\n                }\n              });\n              break;\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      }\n    });\n  }\n  registerEvent(eventName, listener) {\n    const prevEvents = this.events.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.events.set(eventName, nextEvents);\n    this.logger.info(\'registered event "%s"\', eventName, listener);\n  }\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  respondWith(response) {\n    this.logger.info("responding with a mocked response: %d %s", response.status, response.statusText);\n    define(this.request, IS_MOCKED_RESPONSE, true);\n    define(this.request, "status", response.status);\n    define(this.request, "statusText", response.statusText);\n    define(this.request, "responseURL", this.url.href);\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args) => {\n        this.logger.info("getResponseHeader", args[0]);\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info("headers not received yet, returning null");\n          return null;\n        }\n        const headerValue = response.headers.get(args[0]);\n        this.logger.info(\'resolved response header "%s" to\', args[0], headerValue);\n        return headerValue;\n      }\n    });\n    this.request.getAllResponseHeaders = new Proxy(this.request.getAllResponseHeaders, {\n      apply: () => {\n        this.logger.info("getAllResponseHeaders");\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info("headers not received yet, returning empty string");\n          return "";\n        }\n        const headersList = Array.from(response.headers.entries());\n        const allHeaders = headersList.map(([headerName, headerValue]) => {\n          return `\${headerName}: \${headerValue}`;\n        }).join("\\r\\n");\n        this.logger.info("resolved all response headers to", allHeaders);\n        return allHeaders;\n      }\n    });\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML\n      }\n    });\n    const totalResponseBodyLength = response.headers.has("Content-Length") ? Number(response.headers.get("Content-Length")) : (\n    /**\n     * @todo Infer the response body length from the response body.\n     */\n    void 0);\n    this.logger.info("calculated response body length", totalResponseBodyLength);\n    this.trigger("loadstart", {\n      loaded: 0,\n      total: totalResponseBodyLength\n    });\n    this.setReadyState(this.request.HEADERS_RECEIVED);\n    this.setReadyState(this.request.LOADING);\n    const finalizeResponse = () => {\n      this.logger.info("finalizing the mocked response...");\n      this.setReadyState(this.request.DONE);\n      this.trigger("load", {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n      this.trigger("loadend", {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n    };\n    if (response.body) {\n      this.logger.info("mocked response has body, streaming...");\n      const reader = response.body.getReader();\n      const readNextResponseBodyChunk = async () => {\n        const {\n          value,\n          done\n        } = await reader.read();\n        if (done) {\n          this.logger.info("response body stream done!");\n          finalizeResponse();\n          return;\n        }\n        if (value) {\n          this.logger.info("read response body chunk:", value);\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value);\n          this.trigger("progress", {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength\n          });\n        }\n        readNextResponseBodyChunk();\n      };\n      readNextResponseBodyChunk();\n    } else {\n      finalizeResponse();\n    }\n  }\n  responseBufferToText() {\n    return (0, _chunk3YG2666Q.decodeBuffer)(this.responseBuffer);\n  }\n  get response() {\n    this.logger.info("getResponse (responseType: %s)", this.request.responseType);\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    switch (this.request.responseType) {\n      case "json":\n        {\n          const responseJson = parseJson(this.responseBufferToText());\n          this.logger.info("resolved response JSON", responseJson);\n          return responseJson;\n        }\n      case "arraybuffer":\n        {\n          const arrayBuffer = (0, _chunk3YG2666Q.toArrayBuffer)(this.responseBuffer);\n          this.logger.info("resolved response ArrayBuffer", arrayBuffer);\n          return arrayBuffer;\n        }\n      case "blob":\n        {\n          const mimeType = this.request.getResponseHeader("Content-Type") || "text/plain";\n          const responseBlob = new Blob([this.responseBufferToText()], {\n            type: mimeType\n          });\n          this.logger.info("resolved response Blob (mime type: %s)", responseBlob, mimeType);\n          return responseBlob;\n        }\n      default:\n        {\n          const responseText = this.responseBufferToText();\n          this.logger.info(\'resolving "%s" response type as text\', this.request.responseType, responseText);\n          return responseText;\n        }\n    }\n  }\n  get responseText() {\n    (0, _outvariant.invariant)(this.request.responseType === "" || this.request.responseType === "text", "InvalidStateError: The object is in invalid state.");\n    if (this.request.readyState !== this.request.LOADING && this.request.readyState !== this.request.DONE) {\n      return "";\n    }\n    const responseText = this.responseBufferToText();\n    this.logger.info(\'getResponseText: "%s"\', responseText);\n    return responseText;\n  }\n  get responseXML() {\n    (0, _outvariant.invariant)(this.request.responseType === "" || this.request.responseType === "document", "InvalidStateError: The object is in invalid state.");\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    const contentType = this.request.getResponseHeader("Content-Type") || "";\n    if (typeof DOMParser === "undefined") {\n      console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.");\n      return null;\n    }\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(this.responseBufferToText(), contentType);\n    }\n    return null;\n  }\n  errorWith(error) {\n    this.logger.info("responding with an error");\n    this.setReadyState(this.request.DONE);\n    this.trigger("error");\n    this.trigger("loadend");\n  }\n  /**\n   * Transitions this request\'s `readyState` to the given one.\n   */\n  setReadyState(nextReadyState) {\n    this.logger.info("setReadyState: %d -> %d", this.request.readyState, nextReadyState);\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info("ready state identical, skipping transition...");\n      return;\n    }\n    define(this.request, "readyState", nextReadyState);\n    this.logger.info("set readyState to: %d", nextReadyState);\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info(\'triggerring "readystatechange" event...\');\n      this.trigger("readystatechange");\n    }\n  }\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  trigger(eventName, options) {\n    const callback = this.request[`on\${eventName}`];\n    const event = createEvent(this.request, eventName, options);\n    this.logger.info(\'trigger "%s"\', eventName, options || "");\n    if (typeof callback === "function") {\n      this.logger.info(\'found a direct "%s" callback, calling...\', eventName);\n      callback.call(this.request, event);\n    }\n    for (const [registeredEventName, listeners] of this.events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\'found %d listener(s) for "%s" event, calling...\', listeners.length, eventName);\n        listeners.forEach(listener => listener.call(this.request, event));\n      }\n    }\n  }\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  toFetchApiRequest() {\n    this.logger.info("converting request to a Fetch API Request...");\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? "include" : "same-origin",\n      body: ["GET", "HEAD"].includes(this.method) ? null : this.requestBody\n    });\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case "append":\n          case "set":\n            {\n              const [headerName, headerValue] = args;\n              this.request.setRequestHeader(headerName, headerValue);\n              break;\n            }\n          case "delete":\n            {\n              const [headerName] = args;\n              console.warn(`XMLHttpRequest: Cannot remove a "\${headerName}" header from the Fetch API representation of the "\${fetchRequest.method} \${fetchRequest.url}" request. XMLHttpRequest headers cannot be removed.`);\n              break;\n            }\n        }\n        return invoke();\n      }\n    });\n    define(fetchRequest, "headers", proxyHeaders);\n    this.logger.info("converted request to a Fetch API Request!", fetchRequest);\n    return fetchRequest;\n  }\n};\nfunction toAbsoluteUrl(url) {\n  if (typeof location === "undefined") {\n    return new URL(url);\n  }\n  return new URL(url.toString(), location.href);\n}\nfunction define(target, property, value) {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value\n  });\n}\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts\nfunction createXMLHttpRequestProxy({\n  emitter,\n  logger\n}) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info("constructed new XMLHttpRequest");\n      const originalRequest = Reflect.construct(target, args, newTarget);\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(target.prototype);\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(originalRequest, propertyName, prototypeDescriptors[propertyName]);\n      }\n      const xhrRequestController = new XMLHttpRequestController(originalRequest, logger);\n      xhrRequestController.onRequest = async function ({\n        request,\n        requestId\n      }) {\n        const {\n          interactiveRequest,\n          requestController\n        } = (0, _chunkKK6APRON.toInteractiveRequest)(request);\n        this.logger.info("awaiting mocked response...");\n        emitter.once("request", ({\n          requestId: pendingRequestId\n        }) => {\n          if (pendingRequestId !== requestId) {\n            return;\n          }\n          if (requestController.responsePromise.state === "pending") {\n            requestController.respondWith(void 0);\n          }\n        });\n        const resolverResult = await (0, _until.until)(async () => {\n          this.logger.info(\'emitting the "request" event for %s listener(s)...\', emitter.listenerCount("request"));\n          await (0, _chunkKK6APRON.emitAsync)(emitter, "request", {\n            request: interactiveRequest,\n            requestId\n          });\n          this.logger.info(\'all "request" listeners settled!\');\n          const mockedResponse2 = await requestController.responsePromise;\n          this.logger.info("event.respondWith called with:", mockedResponse2);\n          return mockedResponse2;\n        });\n        if (resolverResult.error) {\n          this.logger.info("request listener threw an exception, aborting request...", resolverResult.error);\n          xhrRequestController.errorWith(resolverResult.error);\n          return;\n        }\n        const mockedResponse = resolverResult.data;\n        if (typeof mockedResponse !== "undefined") {\n          this.logger.info("received mocked response: %d %s", mockedResponse.status, mockedResponse.statusText);\n          if (mockedResponse.type === "error") {\n            this.logger.info("received a network error response, rejecting the request promise...");\n            xhrRequestController.errorWith(new TypeError("Network error"));\n            return;\n          }\n          return xhrRequestController.respondWith(mockedResponse);\n        }\n        this.logger.info("no mocked response received, performing request as-is...");\n      };\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId\n      }) {\n        this.logger.info(\'emitting the "response" event for %s listener(s)...\', emitter.listenerCount("response"));\n        emitter.emit("response", {\n          response,\n          isMockedResponse,\n          request,\n          requestId\n        });\n      };\n      return xhrRequestController.request;\n    }\n  });\n  return XMLHttpRequestProxy;\n}\n\n// src/interceptors/XMLHttpRequest/index.ts\nvar _XMLHttpRequestInterceptor = class extends _chunkS72SKXXQ.Interceptor {\n  constructor() {\n    super(_XMLHttpRequestInterceptor.interceptorSymbol);\n  }\n  checkEnvironment() {\n    return typeof globalThis.XMLHttpRequest !== "undefined";\n  }\n  setup() {\n    const logger = this.logger.extend("setup");\n    logger.info(\'patching "XMLHttpRequest" module...\');\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest;\n    (0, _outvariant.invariant)(!PureXMLHttpRequest[_chunkS72SKXXQ.IS_PATCHED_MODULE], \'Failed to patch the "XMLHttpRequest" module: already patched.\');\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger\n    });\n    logger.info(\'native "XMLHttpRequest" module patched!\', globalThis.XMLHttpRequest.name);\n    Object.defineProperty(globalThis.XMLHttpRequest, _chunkS72SKXXQ.IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, _chunkS72SKXXQ.IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.XMLHttpRequest = PureXMLHttpRequest;\n      logger.info(\'native "XMLHttpRequest" module restored!\', globalThis.XMLHttpRequest.name);\n    });\n  }\n};\nvar XMLHttpRequestInterceptor = exports.XMLHttpRequestInterceptor = _XMLHttpRequestInterceptor;\nXMLHttpRequestInterceptor.interceptorSymbol = Symbol("xhr");\n\n},{"./chunk-3YG2666Q.mjs":2,"./chunk-KK6APRON.mjs":3,"./chunk-S72SKXXQ.mjs":5,"@open-draft/until":16,"is-node-process":17,"outvariant":18}],7:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = void 0;\nvar _chunkXILA3UPG = require("../chunk-XILA3UPG.mjs");\nrequire("../chunk-3YG2666Q.mjs");\nvar _chunkKRADPSOF = require("../chunk-KRADPSOF.mjs");\nrequire("../chunk-KK6APRON.mjs");\nrequire("../chunk-S72SKXXQ.mjs");\n// src/presets/browser.ts\nvar browser_default = exports.default = [new _chunkKRADPSOF.FetchInterceptor(), new _chunkXILA3UPG.XMLHttpRequestInterceptor()];\n\n},{"../chunk-3YG2666Q.mjs":2,"../chunk-KK6APRON.mjs":3,"../chunk-KRADPSOF.mjs":4,"../chunk-S72SKXXQ.mjs":5,"../chunk-XILA3UPG.mjs":6}],8:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.isResponseWithoutBody = isResponseWithoutBody;\n// src/utils/responseUtils.ts\nvar RESPONSE_STATUS_CODES_WITHOUT_BODY = /* @__PURE__ */new Set([101, 103, 204, 205, 304]);\nfunction isResponseWithoutBody(status) {\n  return RESPONSE_STATUS_CODES_WITHOUT_BODY.has(status);\n}\n\n},{}],9:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.decodeBuffer = decodeBuffer;\nexports.encodeBuffer = encodeBuffer;\nexports.toArrayBuffer = toArrayBuffer;\n// src/utils/bufferUtils.ts\nvar encoder = new TextEncoder();\nfunction encodeBuffer(text) {\n  return encoder.encode(text);\n}\nfunction decodeBuffer(buffer, encoding) {\n  const decoder = new TextDecoder(encoding);\n  return decoder.decode(buffer);\n}\nfunction toArrayBuffer(array) {\n  return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);\n}\n\n},{}],10:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.IS_PATCHED_MODULE = void 0;\n// src/glossary.ts\nvar IS_PATCHED_MODULE = exports.IS_PATCHED_MODULE = Symbol("isPatchedModule");\n\n},{}],11:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.InterceptorReadyState = exports.Interceptor = void 0;\nexports.deleteGlobalSymbol = deleteGlobalSymbol;\nexports.getGlobalSymbol = getGlobalSymbol;\nvar _logger = require("@open-draft/logger");\nvar _strictEventEmitter = require("strict-event-emitter");\n// src/Interceptor.ts\n\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar InterceptorReadyState = exports.InterceptorReadyState = /* @__PURE__ */(InterceptorReadyState2 => {\n  InterceptorReadyState2["INACTIVE"] = "INACTIVE";\n  InterceptorReadyState2["APPLYING"] = "APPLYING";\n  InterceptorReadyState2["APPLIED"] = "APPLIED";\n  InterceptorReadyState2["DISPOSING"] = "DISPOSING";\n  InterceptorReadyState2["DISPOSED"] = "DISPOSED";\n  return InterceptorReadyState2;\n})(InterceptorReadyState || {});\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = "INACTIVE" /* INACTIVE */;\n    this.emitter = new _strictEventEmitter.Emitter();\n    this.subscriptions = [];\n    this.logger = new _logger.Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info("constructing the interceptor...");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it\'s present.\n   */\n  apply() {\n    const logger = this.logger.extend("apply");\n    logger.info("applying the interceptor...");\n    if (this.readyState === "APPLIED" /* APPLIED */) {\n      logger.info("intercepted already applied!");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info("the interceptor cannot be applied in this environment!");\n      return;\n    }\n    this.readyState = "APPLYING" /* APPLYING */;\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info("found a running instance, reusing...");\n      this.on = (event, listener) => {\n        logger.info(\'proxying the "%s" listener\', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info(\'removed proxied "%s" listener!\', event);\n        });\n        return this;\n      };\n      this.readyState = "APPLIED" /* APPLIED */;\n      return;\n    }\n    logger.info("no running instance found, setting up a new instance...");\n    this.setup();\n    this.setInstance();\n    this.readyState = "APPLIED" /* APPLIED */;\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there\'s a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  setup() {}\n  /**\n   * Listen to the interceptor\'s public events.\n   */\n  on(event, listener) {\n    const logger = this.logger.extend("on");\n    if (this.readyState === "DISPOSING" /* DISPOSING */ || this.readyState === "DISPOSED" /* DISPOSED */) {\n      logger.info("cannot listen to events, already disposed!");\n      return this;\n    }\n    logger.info(\'adding "%s" event listener:\', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  dispose() {\n    const logger = this.logger.extend("dispose");\n    if (this.readyState === "DISPOSED" /* DISPOSED */) {\n      logger.info("cannot dispose, already disposed!");\n      return;\n    }\n    logger.info("disposing the interceptor...");\n    this.readyState = "DISPOSING" /* DISPOSING */;\n    if (!this.getInstance()) {\n      logger.info("no interceptors running, skipping dispose...");\n      return;\n    }\n    this.clearInstance();\n    logger.info("global symbol deleted:", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info("disposing of %d subscriptions...", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info("disposed of all subscriptions!", this.subscriptions.length);\n    }\n    this.emitter.removeAllListeners();\n    logger.info("destroyed the listener!");\n    this.readyState = "DISPOSED" /* DISPOSED */;\n  }\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info("retrieved global instance:", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info("set global instance!", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info("cleared global instance!", this.symbol.description);\n  }\n};\nexports.Interceptor = Interceptor;\n\n},{"@open-draft/logger":15,"strict-event-emitter":20}],12:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.BatchInterceptor = void 0;\nvar _chunkJAW6F2FR = require("./chunk-JAW6F2FR.mjs");\n// src/BatchInterceptor.ts\nvar BatchInterceptor = class extends _chunkJAW6F2FR.Interceptor {\n  constructor(options) {\n    BatchInterceptor.symbol = Symbol(options.name);\n    super(BatchInterceptor.symbol);\n    this.interceptors = options.interceptors;\n  }\n  setup() {\n    const logger = this.logger.extend("setup");\n    logger.info("applying all %d interceptors...", this.interceptors.length);\n    for (const interceptor of this.interceptors) {\n      logger.info(\'applying "%s" interceptor...\', interceptor.constructor.name);\n      interceptor.apply();\n      logger.info("adding interceptor dispose subscription");\n      this.subscriptions.push(() => interceptor.dispose());\n    }\n  }\n  on(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener);\n    }\n    return this;\n  }\n  once(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener);\n    }\n    return this;\n  }\n  off(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener);\n    }\n    return this;\n  }\n  removeAllListeners(event) {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event);\n    }\n    return this;\n  }\n};\nexports.BatchInterceptor = BatchInterceptor;\n\n},{"./chunk-JAW6F2FR.mjs":11}],13:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nObject.defineProperty(exports, "BatchInterceptor", {\n  enumerable: true,\n  get: function () {\n    return _chunkLNYHQTKT.BatchInterceptor;\n  }\n});\nObject.defineProperty(exports, "IS_PATCHED_MODULE", {\n  enumerable: true,\n  get: function () {\n    return _chunkGFH37L5D.IS_PATCHED_MODULE;\n  }\n});\nObject.defineProperty(exports, "Interceptor", {\n  enumerable: true,\n  get: function () {\n    return _chunkJAW6F2FR.Interceptor;\n  }\n});\nObject.defineProperty(exports, "InterceptorReadyState", {\n  enumerable: true,\n  get: function () {\n    return _chunkJAW6F2FR.InterceptorReadyState;\n  }\n});\nObject.defineProperty(exports, "decodeBuffer", {\n  enumerable: true,\n  get: function () {\n    return _chunk7II4SWKS.decodeBuffer;\n  }\n});\nObject.defineProperty(exports, "deleteGlobalSymbol", {\n  enumerable: true,\n  get: function () {\n    return _chunkJAW6F2FR.deleteGlobalSymbol;\n  }\n});\nObject.defineProperty(exports, "encodeBuffer", {\n  enumerable: true,\n  get: function () {\n    return _chunk7II4SWKS.encodeBuffer;\n  }\n});\nexports.getCleanUrl = getCleanUrl;\nObject.defineProperty(exports, "getGlobalSymbol", {\n  enumerable: true,\n  get: function () {\n    return _chunkJAW6F2FR.getGlobalSymbol;\n  }\n});\nObject.defineProperty(exports, "isResponseWithoutBody", {\n  enumerable: true,\n  get: function () {\n    return _chunk5XLKQVVL.isResponseWithoutBody;\n  }\n});\nvar _chunkLNYHQTKT = require("./chunk-LNYHQTKT.mjs");\nvar _chunk7II4SWKS = require("./chunk-7II4SWKS.mjs");\nvar _chunk5XLKQVVL = require("./chunk-5XLKQVVL.mjs");\nvar _chunkGFH37L5D = require("./chunk-GFH37L5D.mjs");\nvar _chunkJAW6F2FR = require("./chunk-JAW6F2FR.mjs");\n// src/utils/getCleanUrl.ts\nfunction getCleanUrl(url, isAbsolute = true) {\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join("");\n}\n\n},{"./chunk-5XLKQVVL.mjs":8,"./chunk-7II4SWKS.mjs":9,"./chunk-GFH37L5D.mjs":10,"./chunk-JAW6F2FR.mjs":11,"./chunk-LNYHQTKT.mjs":12}],14:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.DeferredPromise = void 0;\nexports.createDeferredExecutor = createDeferredExecutor;\n// src/createDeferredExecutor.ts\nfunction createDeferredExecutor() {\n  const executor = (resolve, reject) => {\n    executor.state = "pending";\n    executor.resolve = data => {\n      if (executor.state !== "pending") {\n        return;\n      }\n      executor.result = data;\n      const onFulfilled = value => {\n        executor.state = "fulfilled";\n        return value;\n      };\n      return resolve(data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled));\n    };\n    executor.reject = reason => {\n      if (executor.state !== "pending") {\n        return;\n      }\n      queueMicrotask(() => {\n        executor.state = "rejected";\n      });\n      return reject(executor.rejectionReason = reason);\n    };\n  };\n  return executor;\n}\n\n// src/DeferredPromise.ts\nvar DeferredPromise = class extends Promise {\n  #executor;\n  resolve;\n  reject;\n  constructor(executor = null) {\n    const deferredExecutor = createDeferredExecutor();\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject);\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject);\n    });\n    this.#executor = deferredExecutor;\n    this.resolve = this.#executor.resolve;\n    this.reject = this.#executor.reject;\n  }\n  get state() {\n    return this.#executor.state;\n  }\n  get rejectionReason() {\n    return this.#executor.rejectionReason;\n  }\n  then(onFulfilled, onRejected) {\n    return this.#decorate(super.then(onFulfilled, onRejected));\n  }\n  catch(onRejected) {\n    return this.#decorate(super.catch(onRejected));\n  }\n  finally(onfinally) {\n    return this.#decorate(super.finally(onfinally));\n  }\n  #decorate(promise) {\n    return Object.defineProperties(promise, {\n      resolve: {\n        configurable: true,\n        value: this.resolve\n      },\n      reject: {\n        configurable: true,\n        value: this.reject\n      }\n    });\n  }\n};\nexports.DeferredPromise = DeferredPromise;\n\n},{}],15:[function(require,module,exports){\n(function (process){(function (){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Logger = void 0;\nvar _isNodeProcess = require("is-node-process");\nvar _outvariant = require("outvariant");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/index.ts\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m\${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m\${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m\${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m\${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m\${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = (0, _isNodeProcess.isNodeProcess)();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[\${this.name}]`;\n    const LOGGER_NAME = getVariable("DEBUG");\n    const LOGGER_LEVEL = getVariable("LOG_LEVEL");\n    const isLoggingEnabled = LOGGER_NAME === "1" || LOGGER_NAME === "true" || typeof LOGGER_NAME !== "undefined" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, "debug") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, "info") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, "success") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, "warning") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, "error") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`\${this.name}:\${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug(\'no duplicates found, creating a document...\')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: "debug",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: "gray"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info(\'start parsing...\')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: "info",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: "blue"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: "info",\n        message: `\${message2} \${gray(`\${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: "blue"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success(\'successfully created document\')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: "info",\n      message,\n      positionals,\n      prefix: `\\u2714 \${this.prefix}`,\n      colors: {\n        timestamp: "green",\n        prefix: "green"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning(\'found legacy document format\')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: "warning",\n      message,\n      positionals,\n      prefix: `\\u26A0 \${this.prefix}`,\n      colors: {\n        timestamp: "yellow",\n        prefix: "yellow"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error(\'something went wrong\')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: "error",\n      message,\n      positionals,\n      prefix: `\\u2716 \${this.prefix}`,\n      colors: {\n        timestamp: "red",\n        prefix: "red"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info(\'additional info\')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || "gray";\n    const prefixColor = customColors?.prefix || "gray";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write([colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(" "), ...positionals.map(serializeInput));\n  }\n  formatTimestamp(timestamp) {\n    return `\${timestamp.toLocaleTimeString("en-GB")}:\${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case "debug":\n      case "success":\n      case "info":\n        {\n          return log;\n        }\n      case "warning":\n        {\n          return warn;\n        }\n      case "error":\n        {\n          return error;\n        }\n    }\n  }\n};\nexports.Logger = Logger;\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write((0, _outvariant.format)(message, ...positionals) + "\\n");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write((0, _outvariant.format)(message, ...positionals) + "\\n");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write((0, _outvariant.format)(message, ...positionals) + "\\n");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === "undefined") {\n    return "undefined";\n  }\n  if (message === null) {\n    return "null";\n  }\n  if (typeof message === "string") {\n    return message;\n  }\n  if (typeof message === "object") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\n\n}).call(this)}).call(this,require(\'_process\'))\n},{"_process":19,"is-node-process":17,"outvariant":18}],16:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.until = void 0;\n// src/until.ts\nvar until = async promise => {\n  try {\n    const data = await promise().catch(error => {\n      throw error;\n    });\n    return {\n      error: null,\n      data\n    };\n  } catch (error) {\n    return {\n      error,\n      data: null\n    };\n  }\n};\nexports.until = until;\n\n},{}],17:[function(require,module,exports){\n(function (process){(function (){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.isNodeProcess = isNodeProcess;\n// src/index.ts\nfunction isNodeProcess() {\n  if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {\n    return true;\n  }\n  if (typeof process !== "undefined") {\n    const type = process.type;\n    if (type === "renderer" || type === "worker") {\n      return false;\n    }\n    return !!(process.versions && process.versions.node);\n  }\n  return false;\n}\n\n}).call(this)}).call(this,require(\'_process\'))\n},{"_process":19}],18:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.InvariantError = void 0;\nexports.format = format;\nexports.invariant = void 0;\n// src/format.ts\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case "s":\n      return positional;\n    case "d":\n    case "i":\n      return Number(positional);\n    case "j":\n      return JSON.stringify(positional);\n    case "o":\n      {\n        if (typeof positional === "string") {\n          return positional;\n        }\n        const json = JSON.stringify(positional);\n        if (json === "{}" || json === "[]" || /^\\[object .+?\\]\$/.test(json)) {\n          return positional;\n        }\n        return json;\n      }\n  }\n}\nfunction format(message, ...positionals) {\n  if (positionals.length === 0) {\n    return message;\n  }\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n    return match;\n  });\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` \${positionals.slice(positionalIndex).join(" ")}`;\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, "%");\n  return formattedMessage;\n}\n\n// src/invariant.ts\nvar STACK_FRAMES_TO_IGNORE = 2;\nfunction cleanErrorStack(error) {\n  if (!error.stack) {\n    return;\n  }\n  const nextStack = error.stack.split("\\n");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error.stack = nextStack.join("\\n");\n}\nvar InvariantError = class extends Error {\n  constructor(message, ...positionals) {\n    super(message);\n    this.message = message;\n    this.name = "Invariant Violation";\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n};\nexports.InvariantError = InvariantError;\nvar invariant = (predicate, message, ...positionals) => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals);\n  }\n};\nexports.invariant = invariant;\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error;\n    try {\n      error = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error = ErrorConstructor(formatMessage);\n    }\n    throw error;\n  }\n};\n\n},{}],19:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don\'t break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn\'t define any globals.  It\'s inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error(\'setTimeout has not been defined\');\n}\nfunction defaultClearTimeout () {\n    throw new Error(\'clearTimeout has not been defined\');\n}\n(function () {\n    try {\n        if (typeof setTimeout === \'function\') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \'function\') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn\'t available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn\'t trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it\'s a version of I.E. that must have the global object for \'this\', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn\'t available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn\'t  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it\'s a version of I.E. that must have the global object for \'this\', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = \'\'; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n};\n\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\nprocess.umask = function() { return 0; };\n\n},{}],20:[function(require,module,exports){\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.MemoryLeakError = exports.Emitter = void 0;\n// src/MemoryLeakError.ts\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(`Possible EventEmitter memory leak detected. \${count} \${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = "MaxListenersExceededWarning";\n  }\n};\n\n// src/Emitter.ts\nexports.MemoryLeakError = MemoryLeakError;\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n  constructor() {\n    this.events = /* @__PURE__ */new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(internalEventName, ...[eventName, listener]);\n  }\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    return [];\n  }\n  _wrapOnceListener(eventName, listener) {\n    const onceListener = (...data) => {\n      this.removeListener(eventName, onceListener);\n      return listener.apply(this, data);\n    };\n    Object.defineProperty(onceListener, "name", {\n      value: listener.name\n    });\n    return onceListener;\n  }\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit(\'hello\', \'John\')\n   */\n  emit(eventName, ...data) {\n    const listeners = this._getListeners(eventName);\n    listeners.forEach(listener => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n  addListener(eventName, listener) {\n    this._emitInternalEvent("newListener", eventName, listener);\n    const nextListeners = this._getListeners(eventName).concat(listener);\n    this.events.set(eventName, nextListeners);\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));\n      console.warn(memoryLeakWarning);\n    }\n    return this;\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  once(eventName, listener) {\n    return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n      this.events.set(eventName, listeners);\n      this._emitInternalEvent("removeListener", eventName, listener);\n    }\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off(\'hello\', listener)\n   */\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n};\nvar Emitter = exports.Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10;\n\n},{}]},{},[1]);\n'; // Define MSWJS_BASE here

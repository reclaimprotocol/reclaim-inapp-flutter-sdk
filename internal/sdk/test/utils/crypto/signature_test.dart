import 'dart:convert';

import 'package:flutter_test/flutter_test.dart';
import 'package:reclaim_inapp_sdk/src/utils/crypto/signature.dart';

void main() {
  group('NistP256ECDSASigner', () {
    final message = utf8.encode('Hello, world!');

    test('should create a verifiable signature', () {
      final signer = NistP256ECDSASigner.generate();
      final signature = signer.sign(message);
      final verifier = NistP256ECDSAVerifier(
        kid: signer.kid,
        curveInfo: signer.curveInfo,
        publicKey: signer.keyPair.publicKey,
      );
      expect(verifier.verify(message, signature), isTrue);
    });

    test('should create a verifiable signature from imported key-pairs', () {
      final generatedSigner = NistP256ECDSASigner.generate();
      final importedSigner = NistP256ECDSASigner.fromJwk(generatedSigner.exportPrivateKey());
      final signature = importedSigner.sign(message);
      final verifier = NistP256ECDSAVerifier.fromJwk(generatedSigner.exportPublicKey());
      expect(verifier.verify(message, signature), isTrue);
    });

    test('should verify a constant signature', () {
      final signature = base64.decode(
        '9VtFXMUUbyiq6/nu8tDT8X7sHtXUfeJ9XIXEjA9i01frLinIshLDVOMXqoVyIVSqGQ9GFHXXue37YTmpYVwFog==',
      );
      final verifier = NistP256ECDSAVerifier.fromJwk({
        "key_ops": ["verify"],
        "ext": true,
        "kty": "EC",
        "x": "IR2TLIpcnHoCtx9s_IByDuzWc7V_g9JlVknEkz0YFvY",
        "y": "ZaE2L3jQTkMnqV-bQxnr5QRqL7t2vms_LkvP6bGbkJs",
        "crv": "P-256",
      });
      expect(verifier.verify(message, signature), isTrue);
    });

    // Ensure JS window.crypto.subtle compatible signature
    test('should verify a signature generated by JS window.crypto.subtle', () {
      // Generated in JS with
      // ```
      // const key = await crypto.subtle.generateKey({
      //   name: 'ECDSA',
      //   namedCurve: 'P-256',
      // }, true, ['sign', 'verify']);
      // const publicKey = await crypto.subtle.exportKey('jwk', key.publicKey);
      // const publicKeyString = JSON.stringify(publicKey);
      // ```
      final jwkKeyFromJSSubtleCrypto = {
        'key_ops': ['verify'],
        'ext': true,
        'kty': 'EC',
        'x': 'LpSjB-o59ZPvEI4UmhzfUqfAPA-XBkoppIwMARnbKAo',
        'y': '6P41J4lF6XdsTFTurbzZwip-KFhATKAM2geq8ggvdBU',
        'crv': 'P-256',
      };
      // Generated in JS with
      // ```
      // const message = new TextEncoder().encode('Hello, world!');
      // const signature = await crypto.subtle.sign({
      //   name: 'ECDSA',
      //   hash: 'SHA-256',
      // }, key.privateKey, message);
      // const signatureString = Buffer.from(signature).toString('base64');
      // ```
      final signature = base64.decode(
        'FE7UErr5AO5p4LXne1zEB/MGGcjhQ6iBPNOM/Irg0DfgmHu6cwNCbHeoq3YltOI4qyhf4P0bc/mYwWQOxC165g==',
      );
      final verifier = NistP256ECDSAVerifier.fromJwk(jwkKeyFromJSSubtleCrypto);
      expect(verifier.verify(message, signature), isTrue);
    });

    test('re-imported key must have same kid', () {
      final generatedSigner = NistP256ECDSASigner.generate();
      final importedVerifier = NistP256ECDSAVerifier.fromJwk(generatedSigner.exportPublicKey());
      expect(generatedSigner.exportPublicKey()['kid'], importedVerifier.exportPublicKey()['kid']);
    });
  });
}
